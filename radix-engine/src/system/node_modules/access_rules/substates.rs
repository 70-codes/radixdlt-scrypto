use crate::system::kernel_modules::auth::MethodAuthorization;
use crate::system::kernel_modules::auth::{convert, convert_contextless};
use crate::types::*;
use radix_engine_interface::abi::Type;
use radix_engine_interface::api::component::ComponentStateSubstate;
use radix_engine_interface::blueprints::resource::*;
use radix_engine_interface::data::IndexedScryptoValue;
use crate::errors::RuntimeError;
use crate::kernel::kernel_api::{KernelModuleApi, LockFlags};

/// A transient resource container.
#[derive(Debug, Clone, PartialEq, Eq, ScryptoSbor)]
pub struct PackageAccessRulesSubstate {
    pub access_rules: BTreeMap<(String, String), AccessRule>,
    pub default_auth: AccessRule,
}

/// A transient resource container.
#[derive(Debug, Clone, PartialEq, Eq, ScryptoSbor)]
pub struct ObjectAccessRulesChainSubstate {
    pub access_rules_chain: Vec<AccessRules>,
}

impl ObjectAccessRulesChainSubstate {
    pub fn normal_component_method_authorization(
        &self,
        component_state: &ComponentStateSubstate,
        schema: &Type,
        key: MethodKey,
    ) -> Vec<MethodAuthorization> {
        let data = IndexedScryptoValue::from_slice(&component_state.raw)
            .expect("Failed to decode component state");

        let mut authorizations = Vec::new();
        for auth in &self.access_rules_chain {
            let method_auth = auth.get(&key);
            let authorization = convert(schema, &data, method_auth);
            authorizations.push(authorization);
        }

        authorizations
    }

    pub fn method_authorization_contextless<Y: KernelModuleApi<RuntimeError>>(
        receiver: RENodeId,
        module_id: NodeModuleId,
        key: MethodKey,
        api: &mut Y,
    ) -> Result<Vec<MethodAuthorization>, RuntimeError> {
        let handle = api.kernel_lock_substate(
            receiver,
            module_id,
            SubstateOffset::AccessRulesChain(AccessRulesChainOffset::AccessRulesChain),
            LockFlags::read_only(),
        )?;
        let substate_ref = api.kernel_get_substate_ref(handle)?;
        let access_rules = substate_ref.access_rules_chain();

        let mut authorizations = Vec::new();
        for auth in &access_rules.access_rules_chain {
            let method_auth = auth.get(&key);

            // TODO: Remove
            let authorization = convert_contextless(method_auth);
            authorizations.push(authorization);
        }

        api.kernel_drop_lock(handle)?;

        Ok(authorizations)
    }

    pub fn method_mutability_authorization(&self, key: &MethodKey) -> Vec<MethodAuthorization> {
        let mut authorizations = Vec::new();
        for auth in &self.access_rules_chain {
            let method_auth = auth.get_mutability(key);

            // TODO: Remove
            let authorization = convert_contextless(method_auth);
            authorizations.push(authorization);
        }

        authorizations
    }

    pub fn group_mutability_authorization(&self, name: &str) -> Vec<MethodAuthorization> {
        let mut authorizations = Vec::new();
        for auth in &self.access_rules_chain {
            let group_auth = auth.get_group_mutability(name);

            // TODO: Remove
            let authorization = convert_contextless(group_auth);
            authorizations.push(authorization);
        }

        authorizations
    }
}
