use crate::errors::RuntimeError;
use crate::kernel::kernel_api::KernelModuleApi;
use crate::system::kernel_modules::auth::MethodAuthorization;
use crate::system::kernel_modules::auth::{convert, convert_contextless};
use crate::types::*;
use radix_engine_interface::abi::Type;
use radix_engine_interface::api::component::{ComponentStateSubstate, TypeInfoSubstate};
use radix_engine_interface::api::LockFlags;
use radix_engine_interface::api::package::PackageInfoSubstate;
use radix_engine_interface::blueprints::resource::*;
use radix_engine_interface::data::IndexedScryptoValue;

/// A transient resource container.
#[derive(Debug, Clone, PartialEq, Eq, ScryptoSbor)]
pub struct PackageAccessRulesSubstate {
    pub access_rules: BTreeMap<(String, String), AccessRule>,
    pub default_auth: AccessRule,
}

/// A transient resource container.
#[derive(Debug, Clone, PartialEq, Eq, ScryptoSbor)]
pub struct ObjectAccessRulesChainSubstate {
    pub access_rules_chain: Vec<AccessRules>,
}

impl ObjectAccessRulesChainSubstate {
    pub fn normal_component_method_authorization<Y: KernelModuleApi<RuntimeError>>(
        receiver: RENodeId,
        module_id: NodeModuleId,
        key: MethodKey,
        api: &mut Y,
    ) -> Result<Vec<MethodAuthorization>, RuntimeError> {
        let schema = {
            let handle = api.kernel_lock_substate(
                receiver,
                NodeModuleId::TypeInfo,
                SubstateOffset::TypeInfo(TypeInfoOffset::TypeInfo),
                LockFlags::read_only(),
            )?;
            let info: &TypeInfoSubstate = api.kernel_get_substate_ref(handle)?;
            let package_address = info.package_address.clone();
            let blueprint_ident = info.blueprint_name.clone();

            api.kernel_drop_lock(handle)?;
            let handle = api.kernel_lock_substate(
                RENodeId::GlobalPackage(package_address),
                NodeModuleId::SELF,
                SubstateOffset::Package(PackageOffset::Info),
                LockFlags::read_only(),
            )?;
            let package: &PackageInfoSubstate = api.kernel_get_substate_ref(handle)?;

            let schema = package
                .blueprint_abi(&blueprint_ident)
                .expect("Blueprint not found for existing component")
                .structure
                .clone();
            api.kernel_drop_lock(handle)?;
            schema
        };

        let state = {
            let offset = SubstateOffset::Component(ComponentOffset::State0);
            let handle = api.kernel_lock_substate(
                receiver,
                NodeModuleId::SELF,
                offset,
                LockFlags::read_only(),
            )?;
            let state: &ComponentStateSubstate = api.kernel_get_substate_ref(handle)?;
            let state = IndexedScryptoValue::from_slice(&state.raw)
                .expect("Failed to decode component state");
            api.kernel_drop_lock(handle)?;
            state
        };

        let mut authorizations = Vec::new();

        let handle = api.kernel_lock_substate(
            receiver,
            module_id,
            SubstateOffset::AccessRulesChain(AccessRulesChainOffset::AccessRulesChain),
            LockFlags::read_only(),
        )?;
        let access_rules: &ObjectAccessRulesChainSubstate = api.kernel_get_substate_ref(handle)?;

        for auth in &access_rules.access_rules_chain {
            let method_auth = auth.get(&key);
            let authorization = convert(&schema, &state, method_auth);
            authorizations.push(authorization);
        }

        api.kernel_drop_lock(handle)?;

        Ok(authorizations)
    }

    pub fn method_authorization_contextless<Y: KernelModuleApi<RuntimeError>>(
        receiver: RENodeId,
        module_id: NodeModuleId,
        key: MethodKey,
        api: &mut Y,
    ) -> Result<Vec<MethodAuthorization>, RuntimeError> {
        let handle = api.kernel_lock_substate(
            receiver,
            module_id,
            SubstateOffset::AccessRulesChain(AccessRulesChainOffset::AccessRulesChain),
            LockFlags::read_only(),
        )?;
        let access_rules: &ObjectAccessRulesChainSubstate = api.kernel_get_substate_ref(handle)?;

        let mut authorizations = Vec::new();
        for auth in &access_rules.access_rules_chain {
            let method_auth = auth.get(&key);

            // TODO: Remove
            let authorization = convert_contextless(method_auth);
            authorizations.push(authorization);
        }

        api.kernel_drop_lock(handle)?;

        Ok(authorizations)
    }

    pub fn method_mutability_authorization(&self, key: &MethodKey) -> Vec<MethodAuthorization> {
        let mut authorizations = Vec::new();
        for auth in &self.access_rules_chain {
            let method_auth = auth.get_mutability(key);

            // TODO: Remove
            let authorization = convert_contextless(method_auth);
            authorizations.push(authorization);
        }

        authorizations
    }

    pub fn group_mutability_authorization(&self, name: &str) -> Vec<MethodAuthorization> {
        let mut authorizations = Vec::new();
        for auth in &self.access_rules_chain {
            let group_auth = auth.get_group_mutability(name);

            // TODO: Remove
            let authorization = convert_contextless(group_auth);
            authorizations.push(authorization);
        }

        authorizations
    }
}
