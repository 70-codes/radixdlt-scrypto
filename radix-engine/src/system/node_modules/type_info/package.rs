use crate::errors::*;
use crate::kernel::kernel_api::KernelSubstateApi;
use crate::types::*;
use radix_engine_interface::api::substate_api::LockFlags;
use radix_engine_interface::api::types::{RENodeId, SubstateOffset};
use radix_engine_interface::schema::KeyValueStoreSchema;

#[derive(Debug, Clone, PartialEq, Eq, ScryptoSbor)]
pub enum TypeInfoSubstate {
    Object {
        package_address: PackageAddress,
        blueprint_name: String,
        global: bool,
    },
    KeyValueStore(KeyValueStoreSchema),
}

impl TypeInfoSubstate {
    pub fn new(package_address: PackageAddress, blueprint_name: String, global: bool) -> Self {
        Self::Object {
            package_address,
            blueprint_name,
            global,
        }
    }
}

pub struct TypeInfoBlueprint;

impl TypeInfoBlueprint {
    pub(crate) fn get_type<Y>(
        receiver: &RENodeId,
        api: &mut Y,
    ) -> Result<TypeInfoSubstate, RuntimeError>
    where
        Y: KernelSubstateApi,
    {
        let handle = api.kernel_lock_substate(
            receiver.clone(),
            NodeModuleId::TypeInfo,
            SubstateOffset::TypeInfo(TypeInfoOffset::TypeInfo),
            LockFlags::read_only(),
        )?;
        let info: &TypeInfoSubstate = api.kernel_get_substate_ref(handle)?;
        let info = info.clone();
        api.kernel_drop_lock(handle)?;
        Ok(info)
    }
}
