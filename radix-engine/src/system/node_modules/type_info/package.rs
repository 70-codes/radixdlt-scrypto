use crate::errors::*;
use crate::kernel::kernel_api::KernelSubstateApi;
use crate::types::*;
use radix_engine_interface::api::substate_api::LockFlags;
use radix_engine_interface::api::types::{RENodeId, SubstateOffset};

#[derive(Debug, Clone, PartialEq, Eq, ScryptoSbor)]
pub struct TypeInfoSubstate {
    pub package_address: PackageAddress,
    pub blueprint_name: String,
    pub global: bool,
}

impl TypeInfoSubstate {
    pub fn new(package_address: PackageAddress, blueprint_name: String, global: bool) -> Self {
        Self {
            package_address,
            blueprint_name,
            global,
        }
    }
}

pub struct TypeInfoBlueprint;

impl TypeInfoBlueprint {
    pub(crate) fn get_type<Y>(
        receiver: RENodeId,
        api: &mut Y,
    ) -> Result<(PackageAddress, String), RuntimeError>
        where
            Y: KernelSubstateApi,
    {
        let handle = api.kernel_lock_substate(
            receiver,
            NodeModuleId::TypeInfo,
            SubstateOffset::TypeInfo(TypeInfoOffset::TypeInfo),
            LockFlags::read_only(),
        )?;
        let info: &TypeInfoSubstate = api.kernel_get_substate_ref(handle)?;
        let package_address = info.package_address;
        let blueprint_ident = info.blueprint_name.clone();
        api.kernel_drop_lock(handle)?;
        Ok((package_address, blueprint_ident))
    }
}
