use crate::*;
#[cfg(feature = "radix_engine_fuzzing")]
use arbitrary::Arbitrary;
use radix_engine_common::crypto::PublicKey;
use radix_engine_common::crypto::PublicKeyHash;
use radix_engine_common::data::scrypto::model::NonFungibleLocalId;
use radix_engine_common::data::scrypto::model::Own;
use radix_engine_common::math::Decimal;
use radix_engine_common::time::Instant;
use radix_engine_common::types::GlobalAddress;
use radix_engine_interface::blueprints::resource::NonFungibleGlobalId;
use sbor::rust::fmt::Debug;
use sbor::rust::prelude::*;

pub const METADATA_BLUEPRINT: &str = "Metadata";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub enum MetadataValue {
    #[sbor(discriminator(METADATA_VALUE_STRING_TYPE_ID))]
    String(String),
    #[sbor(discriminator(METADATA_VALUE_BOOLEAN_TYPE_ID))]
    Bool(bool),
    #[sbor(discriminator(METADATA_VALUE_U8_TYPE_ID))]
    U8(u8),
    #[sbor(discriminator(METADATA_VALUE_U32_TYPE_ID))]
    U32(u32),
    #[sbor(discriminator(METADATA_VALUE_U64_TYPE_ID))]
    U64(u64),
    #[sbor(discriminator(METADATA_VALUE_I32_TYPE_ID))]
    I32(i32),
    #[sbor(discriminator(METADATA_VALUE_I64_TYPE_ID))]
    I64(i64),
    #[sbor(discriminator(METADATA_VALUE_DECIMAL_TYPE_ID))]
    Decimal(Decimal),
    #[sbor(discriminator(METADATA_VALUE_GLOBAL_ADDRESS_TYPE_ID))]
    GlobalAddress(GlobalAddress),
    #[sbor(discriminator(METADATA_VALUE_PUBLIC_KEY_TYPE_ID))]
    PublicKey(PublicKey),
    #[sbor(discriminator(METADATA_VALUE_NON_FUNGIBLE_GLOBAL_ID_TYPE_ID))]
    NonFungibleGlobalId(NonFungibleGlobalId),
    #[sbor(discriminator(METADATA_VALUE_NON_FUNGIBLE_LOCAL_ID_TYPE_ID))]
    NonFungibleLocalId(NonFungibleLocalId),
    #[sbor(discriminator(METADATA_VALUE_INSTANT_TYPE_ID))]
    Instant(Instant),
    #[sbor(discriminator(METADATA_VALUE_URL_TYPE_ID))]
    Url(Url),
    #[sbor(discriminator(METADATA_VALUE_ORIGIN_TYPE_ID))]
    Origin(Origin),
    #[sbor(discriminator(METADATA_VALUE_PUBLIC_KEY_HASH_TYPE_ID))]
    PublicKeyHash(PublicKeyHash),
}

pub const METADATA_VALUE_STRING_TYPE_ID: u8 = 0u8;
pub const METADATA_VALUE_BOOLEAN_TYPE_ID: u8 = 1u8;
pub const METADATA_VALUE_U8_TYPE_ID: u8 = 2u8;
pub const METADATA_VALUE_U32_TYPE_ID: u8 = 3u8;
pub const METADATA_VALUE_U64_TYPE_ID: u8 = 4u8;
pub const METADATA_VALUE_I32_TYPE_ID: u8 = 5u8;
pub const METADATA_VALUE_I64_TYPE_ID: u8 = 6u8;
pub const METADATA_VALUE_DECIMAL_TYPE_ID: u8 = 7u8;
pub const METADATA_VALUE_GLOBAL_ADDRESS_TYPE_ID: u8 = 8u8;
pub const METADATA_VALUE_PUBLIC_KEY_TYPE_ID: u8 = 9u8;
pub const METADATA_VALUE_NON_FUNGIBLE_GLOBAL_ID_TYPE_ID: u8 = 10u8;
pub const METADATA_VALUE_NON_FUNGIBLE_LOCAL_ID_TYPE_ID: u8 = 11u8;
pub const METADATA_VALUE_INSTANT_TYPE_ID: u8 = 12u8;
pub const METADATA_VALUE_URL_TYPE_ID: u8 = 13u8;
pub const METADATA_VALUE_ORIGIN_TYPE_ID: u8 = 14u8;
pub const METADATA_VALUE_PUBLIC_KEY_HASH_TYPE_ID: u8 = 15u8;

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
#[sbor(transparent)]
pub struct Url(pub String);

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
#[sbor(transparent)]
pub struct Origin(pub String);

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub enum MetadataEntry {
    #[sbor(discriminator(METADATA_ENTRY_VALUE_TYPE_ID))]
    Value(MetadataValue),
    #[sbor(discriminator(METADATA_ENTRY_LIST_TYPE_ID))]
    List(Vec<MetadataValue>),
}

pub const METADATA_ENTRY_VALUE_TYPE_ID: u8 = 0u8;
pub const METADATA_ENTRY_LIST_TYPE_ID: u8 = 1u8;

pub trait MetadataVal: Sized {
    fn to_metadata_entry(self) -> MetadataEntry;

    fn from_metadata_entry(entry: MetadataEntry) -> Result<Self, MetadataError>;
}

macro_rules! impl_metadata_val {
    ($rust_type:ty, $metadata_type:tt, $type_id:expr) => {
        impl MetadataVal for $rust_type {
            fn to_metadata_entry(self) -> MetadataEntry {
                MetadataEntry::Value(MetadataValue::$metadata_type(self))
            }

            fn from_metadata_entry(entry: MetadataEntry) -> Result<Self, MetadataError> {
                match entry {
                    MetadataEntry::Value(value) => match value {
                        MetadataValue::$metadata_type(x) => Ok(x),
                        x => Err(MetadataError::UnexpectedValue {
                            expected_type_id: $type_id,
                            actual: x,
                        }),
                    },
                    MetadataEntry::List(_) => Err(MetadataError::ExpectedValueButFoundList),
                }
            }
        }

        impl MetadataVal for Vec<$rust_type> {
            fn to_metadata_entry(self) -> MetadataEntry {
                MetadataEntry::List(
                    self.into_iter()
                        .map(|x| MetadataValue::$metadata_type(x))
                        .collect(),
                )
            }

            fn from_metadata_entry(entry: MetadataEntry) -> Result<Self, MetadataError> {
                match entry {
                    MetadataEntry::Value(_) => Err(MetadataError::ExpectedListButFoundValue),
                    MetadataEntry::List(list) => {
                        let mut results = Vec::new();
                        for entry in list {
                            match entry {
                                MetadataValue::$metadata_type(x) => {
                                    results.push(x);
                                }
                                value => {
                                    return Err(MetadataError::UnexpectedValue {
                                        expected_type_id: $type_id,
                                        actual: value,
                                    });
                                }
                            }
                        }
                        Ok(results)
                    }
                }
            }
        }
    };
}

impl_metadata_val!(String, String, METADATA_VALUE_BOOLEAN_TYPE_ID);
impl_metadata_val!(bool, Bool, METADATA_VALUE_BOOLEAN_TYPE_ID);
impl_metadata_val!(u8, U8, METADATA_VALUE_U8_TYPE_ID);
impl_metadata_val!(u32, U32, METADATA_VALUE_U32_TYPE_ID);
impl_metadata_val!(u64, U64, METADATA_VALUE_U64_TYPE_ID);
impl_metadata_val!(i32, I32, METADATA_VALUE_I32_TYPE_ID);
impl_metadata_val!(i64, I64, METADATA_VALUE_I64_TYPE_ID);
impl_metadata_val!(Decimal, Decimal, METADATA_VALUE_DECIMAL_TYPE_ID);
impl_metadata_val!(
    GlobalAddress,
    GlobalAddress,
    METADATA_VALUE_GLOBAL_ADDRESS_TYPE_ID
);
impl_metadata_val!(PublicKey, PublicKey, METADATA_VALUE_PUBLIC_KEY_TYPE_ID);
impl_metadata_val!(
    NonFungibleGlobalId,
    NonFungibleGlobalId,
    METADATA_VALUE_PUBLIC_KEY_TYPE_ID
);
impl_metadata_val!(
    NonFungibleLocalId,
    NonFungibleLocalId,
    METADATA_VALUE_NON_FUNGIBLE_LOCAL_ID_TYPE_ID
);
impl_metadata_val!(Instant, Instant, METADATA_VALUE_INSTANT_TYPE_ID);
impl_metadata_val!(Url, Url, METADATA_VALUE_URL_TYPE_ID);

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor)]
pub enum MetadataError {
    ExpectedValueButFoundList,

    ExpectedListButFoundValue,

    UnexpectedValue {
        expected_type_id: u8,
        actual: MetadataValue,
    },

    EmptyEntry,
}

pub const METADATA_CREATE_IDENT: &str = "create";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub struct MetadataCreateInput {}

pub type MetadataCreateOutput = Own;

pub const METADATA_CREATE_WITH_DATA_IDENT: &str = "create_with_data";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub struct MetadataCreateWithDataInput {
    pub data: BTreeMap<String, String>,
}

pub type MetadataCreateWithDataOutput = Own;

pub const METADATA_SET_IDENT: &str = "set";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub struct MetadataSetInput {
    pub key: String,
    pub value: MetadataEntry,
}

pub type MetadataSetOutput = ();

pub const METADATA_GET_IDENT: &str = "get";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub struct MetadataGetInput {
    pub key: String,
}

pub type MetadataGetOutput = Option<MetadataEntry>;

pub const METADATA_REMOVE_IDENT: &str = "remove";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub struct MetadataRemoveInput {
    pub key: String,
}

pub type MetadataRemoveOutput = bool;
