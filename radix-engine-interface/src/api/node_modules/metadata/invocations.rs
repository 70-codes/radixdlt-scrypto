use crate::*;
use radix_engine_common::crypto::PublicKey;
use radix_engine_common::data::scrypto::model::Address;
use radix_engine_common::data::scrypto::{
    scrypto_decode, scrypto_encode, ScryptoCustomValue, ScryptoValue,
};
use radix_engine_common::math::Decimal;
use radix_engine_interface::blueprints::resource::NonFungibleGlobalId;
use sbor::rust::fmt::Debug;
use sbor::rust::prelude::*;
use sbor::Value;

pub const METADATA_BLUEPRINT: &str = "Metadata";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub enum MetadataValue {
    String(String),
    Bool(bool),
    U8(u8),
    U32(u32),
    U64(u64),
    I32(i32),
    I64(i64),
    Decimal(Decimal),
    Address(Address),
    PublicKey(PublicKey),
    NonFungibleGlobalId(NonFungibleGlobalId),
}

pub const METADATA_STRING_TYPE_ID: u8 = 0u8;
pub const METADATA_BOOLEAN_TYPE_ID: u8 = 1u8;
pub const METADATA_U8_TYPE_ID: u8 = 2u8;
pub const METADATA_U32_TYPE_ID: u8 = 3u8;
pub const METADATA_U64_TYPE_ID: u8 = 4u8;
pub const METADATA_I32_TYPE_ID: u8 = 5u8;
pub const METADATA_I64_TYPE_ID: u8 = 6u8;
pub const METADATA_DECIMAL_TYPE_ID: u8 = 7u8;
pub const METADATA_ADDRESS_TYPE_ID: u8 = 8u8;
pub const METADATA_PUBLIC_KEY_TYPE_ID: u8 = 9u8;
pub const METADATA_NON_FUNGIBLE_GLOBAL_ID_TYPE_ID: u8 = 10u8;

pub trait MetadataVal: Sized {
    const TYPE_ID: u8;

    fn to_scrypto_value(self) -> ScryptoValue;

    fn from_scrypto_value(value: ScryptoValue) -> Self;

    fn to_metadata_value(self) -> ScryptoValue {
        ScryptoValue::Enum {
            discriminator: Self::TYPE_ID,
            fields: vec![self.to_scrypto_value()],
        }
    }

    fn from_metadata_value(value: ScryptoValue) -> Result<Self, MetadataError> {
        let (discriminator, value) = match value {
            ScryptoValue::Enum {
                discriminator,
                fields,
            } => {
                let value = fields.into_iter().next().unwrap();
                (discriminator, value)
            }
            _ => panic!("Unexpected"),
        };

        if discriminator == Self::TYPE_ID {
            Ok(Self::from_scrypto_value(value))
        } else {
            Err(MetadataError::NotAString)
        }
    }
}

macro_rules! metadata_type {
    // with describe
    ($t:ty, $type_id:ident, $scrypto_value_type:ident) => {
        impl MetadataVal for $t {
            const TYPE_ID: u8 = $type_id;

            fn to_scrypto_value(self) -> ScryptoValue {
                Value::$scrypto_value_type { value: self }
            }

            fn from_scrypto_value(value: ScryptoValue) -> Self {
                match value {
                    Value::$scrypto_value_type { value } => value,
                    _ => panic!("Unexpected"),
                }
            }
        }
    };
}

metadata_type!(String, METADATA_STRING_TYPE_ID, String);

metadata_type!(bool, METADATA_BOOLEAN_TYPE_ID, Bool);

metadata_type!(u8, METADATA_U8_TYPE_ID, U8);

metadata_type!(u32, METADATA_U32_TYPE_ID, U32);

metadata_type!(u64, METADATA_U64_TYPE_ID, U64);

metadata_type!(i32, METADATA_I32_TYPE_ID, I32);

metadata_type!(i64, METADATA_I64_TYPE_ID, I64);

impl MetadataVal for Decimal {
    const TYPE_ID: u8 = METADATA_DECIMAL_TYPE_ID;

    fn to_scrypto_value(self) -> ScryptoValue {
        Value::Custom {
            value: ScryptoCustomValue::Decimal(self),
        }
    }

    fn from_scrypto_value(value: ScryptoValue) -> Self {
        match value {
            Value::Custom {
                value: ScryptoCustomValue::Decimal(value),
            } => value,
            _ => panic!("Unexpected"),
        }
    }
}

impl MetadataVal for Address {
    const TYPE_ID: u8 = METADATA_ADDRESS_TYPE_ID;

    fn to_scrypto_value(self) -> ScryptoValue {
        Value::Custom {
            value: ScryptoCustomValue::Address(self),
        }
    }

    fn from_scrypto_value(value: ScryptoValue) -> Self {
        match value {
            Value::Custom {
                value: ScryptoCustomValue::Address(value),
            } => value,
            _ => panic!("Unexpected"),
        }
    }
}

impl MetadataVal for PublicKey {
    const TYPE_ID: u8 = METADATA_PUBLIC_KEY_TYPE_ID;

    fn to_scrypto_value(self) -> ScryptoValue {
        let scrypto_value: ScryptoValue = scrypto_decode(&scrypto_encode(&self).unwrap()).unwrap();
        scrypto_value
    }

    fn from_scrypto_value(value: ScryptoValue) -> Self {
        let key: PublicKey = scrypto_decode(&scrypto_encode(&value).unwrap()).unwrap();
        key
    }
}

impl MetadataVal for NonFungibleGlobalId {
    const TYPE_ID: u8 = METADATA_PUBLIC_KEY_TYPE_ID;

    fn to_scrypto_value(self) -> ScryptoValue {
        let scrypto_value: ScryptoValue = scrypto_decode(&scrypto_encode(&self).unwrap()).unwrap();
        scrypto_value
    }

    fn from_scrypto_value(value: ScryptoValue) -> Self {
        let value: NonFungibleGlobalId = scrypto_decode(&scrypto_encode(&value).unwrap()).unwrap();
        value
    }
}

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor)]
pub enum MetadataError {
    NotAString,
    EmptyEntry,
}

pub const METADATA_CREATE_IDENT: &str = "create";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataCreateInput {}

pub const METADATA_CREATE_WITH_DATA_IDENT: &str = "create_with_data";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataCreateWithDataInput {
    pub data: BTreeMap<String, String>,
}

pub const METADATA_SET_IDENT: &str = "set";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor)]
pub struct MetadataSet {
    pub key: String,
    pub value: ScryptoValue,
}

pub const METADATA_GET_IDENT: &str = "get";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataGetInput {
    pub key: String,
}

pub const METADATA_REMOVE_IDENT: &str = "remove";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataRemoveInput {
    pub key: String,
}
