use crate::internal_prelude::*;
use crate::*;
#[cfg(feature = "radix_engine_fuzzing")]
use arbitrary::Arbitrary;
use sbor::rust::fmt::Debug;
use sbor::rust::prelude::*;

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
#[sbor(transparent)]
pub struct Url(pub String);

impl Url {
    pub fn of(value: impl Into<String>) -> Self {
        Self(value.into())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, ScryptoSbor)]
pub enum URLValidationError {
    InvalidUrl(String),
    NotAllowedSchema(String),
    UsernameTooLong { max: usize, actual: usize },
    PasswordTooLong { max: usize, actual: usize },
    MissingHost,
    DomainTooLong { max: usize, actual: usize },
    PathTooLong { max: usize, actual: usize },
    QueryTooLong { max: usize, actual: usize },
    FragmentTooLong { max: usize, actual: usize },
}

/// Validates a URL and enforced additional Radix constraints.
pub fn validate_url(url: &str) -> Result<url::Url, URLValidationError> {
    let url = url::Url::parse(url).map_err(|_| URLValidationError::InvalidUrl(url.to_string()))?;

    // Restrict schema
    let schema = url.scheme(); // lower-cased
    if schema.ne("http") && schema.ne("https") {
        return Err(URLValidationError::NotAllowedSchema(schema.to_string()));
    }

    // Restrict user name
    let user_name = url.username(); // percent-encoded ASCII string
    if user_name.len() > URL_MAX_USERNAME_LEN {
        return Err(URLValidationError::UsernameTooLong {
            max: URL_MAX_USERNAME_LEN,
            actual: user_name.len(),
        });
    }

    // Restrict password
    let password = url.password(); // percent-encoded ASCII string
    if let Some(password) = password {
        if password.len() > URL_MAX_PASSWORD_LEN {
            return Err(URLValidationError::PasswordTooLong {
                max: URL_MAX_PASSWORD_LEN,
                actual: password.len(),
            });
        }
    }

    // Check host and port
    let host = url.host(); // Non-ASCII domain labels are punycode-encoded per IDNA
    if let Some(host) = host {
        match host {
            url::Host::Domain(domain) => {
                if domain.len() > URL_MAX_DOMAIN_LEN {
                    return Err(URLValidationError::DomainTooLong {
                        max: URL_MAX_DOMAIN_LEN,
                        actual: domain.len(),
                    });
                }
            }
            url::Host::Ipv4(_) => {}
            url::Host::Ipv6(_) => {}
        }
    }
    let _port = url.port();

    // Check path
    let path = url.path(); // percent-encoded ASCII string.
    if path.len() > URL_MAX_PATH_LEN {
        return Err(URLValidationError::PathTooLong {
            max: URL_MAX_PATH_LEN,
            actual: path.len(),
        });
    }

    // Check query
    let query = url.query(); // percent-encoded ASCII string.
    if let Some(query) = query {
        if query.len() > URL_MAX_QUERY_LEN {
            return Err(URLValidationError::QueryTooLong {
                max: URL_MAX_QUERY_LEN,
                actual: query.len(),
            });
        }
    }

    // Check fragment
    let fragment = url.fragment(); // percent-encoded ASCII string.
    if let Some(fragment) = fragment {
        if fragment.len() > URL_MAX_FRAGMENT_LEN {
            return Err(URLValidationError::FragmentTooLong {
                max: URL_MAX_FRAGMENT_LEN,
                actual: fragment.len(),
            });
        }
    }

    Ok(url)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[macro_export]
    macro_rules! validate_url_success {
        ( $input: expr, $expected: expr) => {{
            assert_eq!(
                validate_url($input).map(Into::into),
                Ok($expected.to_owned())
            );
            assert_eq!(
                validate_url($expected).map(Into::into),
                Ok($expected.to_owned())
            );
        }};
    }

    #[macro_export]
    macro_rules! validate_url_failure {
        ( $input: expr, $expected: expr) => {{
            assert_eq!(validate_url($input), Err($expected));
        }};
    }

    #[test]
    fn test_validate_url() {
        validate_url_success!(
            "Https://user‰∏≠name:passÊñáword@Example.ÊµãËØï.com/abc/üíñ?key=ËÄÅËôé#fragment%65",
            "https://user%E4%B8%ADname:pass%E6%96%87word@example.xn--0zwm56d.com/abc/%F0%9F%92%96?key=%E8%80%81%E8%99%8E#fragment%65"
        );
        validate_url_failure!(
            "httpexample.com",
            URLValidationError::InvalidUrl("httpexample.com".to_string())
        );
        validate_url_failure!(
            "ftp://google.com",
            URLValidationError::NotAllowedSchema("ftp".to_string())
        );
        validate_url_failure!(
            format!(
                "http://{}:password@example.com/path?query#fragment",
                "x".repeat(URL_MAX_USERNAME_LEN + 1)
            )
            .as_str(),
            URLValidationError::UsernameTooLong {
                max: URL_MAX_USERNAME_LEN,
                actual: URL_MAX_USERNAME_LEN + 1
            }
        );
        validate_url_failure!(
            format!(
                "http://username:{}@example.com/path?query#fragment",
                "x".repeat(URL_MAX_PASSWORD_LEN + 1)
            )
            .as_str(),
            URLValidationError::PasswordTooLong {
                max: URL_MAX_PASSWORD_LEN,
                actual: URL_MAX_PASSWORD_LEN + 1
            }
        );
        validate_url_failure!(
            format!(
                "http://username:password@{}/path?query#fragment",
                "x".repeat(URL_MAX_DOMAIN_LEN + 1)
            )
            .as_str(),
            URLValidationError::DomainTooLong {
                max: URL_MAX_DOMAIN_LEN,
                actual: URL_MAX_DOMAIN_LEN + 1
            }
        );
        validate_url_failure!(
            format!(
                "http://username:password@example.com/{}?query#fragment",
                "x".repeat(URL_MAX_PATH_LEN) // path includes the leading `/`
            )
            .as_str(),
            URLValidationError::PathTooLong {
                max: URL_MAX_PATH_LEN,
                actual: URL_MAX_PATH_LEN + 1
            }
        );
        validate_url_failure!(
            format!(
                "http://username:password@example.com/path?{}#fragment",
                "x".repeat(URL_MAX_QUERY_LEN + 1)
            )
            .as_str(),
            URLValidationError::QueryTooLong {
                max: URL_MAX_QUERY_LEN,
                actual: URL_MAX_QUERY_LEN + 1
            }
        );
        validate_url_failure!(
            format!(
                "http://username:password@example.com/path?query#{}",
                "x".repeat(URL_MAX_FRAGMENT_LEN + 1)
            )
            .as_str(),
            URLValidationError::FragmentTooLong {
                max: URL_MAX_FRAGMENT_LEN,
                actual: URL_MAX_FRAGMENT_LEN + 1
            }
        );
    }
}
