use crate::*;
#[cfg(feature = "radix_engine_fuzzing")]
use arbitrary::Arbitrary;
use lazy_static::lazy_static;
use radix_engine_common::prelude::*;
use regex::Regex;

lazy_static! {
    /// This regular expressions only cover the most commonly used types of URLs.
    ///
    /// Based on https://en.wikipedia.org/wiki/URL#/media/File:URI_syntax_diagram.svg
    ///
    static ref URL_REGEX: Regex = Regex::new(
        concat!(
            // Start
            "^",
            // Schema: http or https
            "https?",
            // ://
            ":\\/\\/",
            // Userinfo: not allowed
            // Host: ip address or host name
            // From https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
            "(",
                "((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))",
                "|",
                "((([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9]))",
            ")",
            // Port number, optional
            // From https://stackoverflow.com/questions/12968093/regex-to-validate-port-number
            "(:([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?",
            // Path, optional
            "(\\/[-a-zA-Z0-9_]*)*",
            // Query, optional
            "(\\?[-a-zA-Z0-9()@:%_\\+.~&\\/=]*)?",
            // Fragment: not allowed
            // End
            "$"
        )
    ).unwrap();
}

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
#[sbor(transparent)]
pub struct Url(String);

impl Url {
    pub fn of(value: impl AsRef<str>) -> Option<Self> {
        let s = value.as_ref();
        if s.len() <= MAX_URL_LENGTH && URL_REGEX.is_match(s) {
            Some(Self(s.to_owned()))
        } else {
            None
        }
    }

    /// Bypass validation, and create a `Url` instance
    pub fn of_unchecked(value: impl AsRef<str>) -> Self {
        Self(value.as_ref().to_owned())
    }

    pub fn as_str(&self) -> &str {
        self.0.as_str()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_url() {
        assert!(Url::of("https://66.123.1.255:9999").is_some());
        assert!(Url::of("https://66.123.1.255:9999/hi").is_some());
        assert!(Url::of("https://www.google.com").is_some());
        assert!(Url::of("https://www.google.com/").is_some());
        assert!(Url::of("https://www.google.com/test/_abc/path").is_some());
        assert!(Url::of("https://www.google.com/test/_abc/path?").is_some());
        assert!(Url::of("https://www.google.com/test/_abc/path?abc=%12&def=test").is_some());
        assert!(Url::of("https://username:password@www.google.com").is_none()); // not supported
        assert!(Url::of("https://www.google.com/test/_abc/path?abc=%12&def=test#").is_none());
        // not supported
    }
}
