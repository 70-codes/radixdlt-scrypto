use crate::api::ObjectModuleId;
use crate::blueprints::resource::*;
use crate::types::KeyValueStoreInitEntry;
use crate::*;
#[cfg(feature = "radix_engine_fuzzing")]
use arbitrary::Arbitrary;
use radix_engine_common::data::scrypto::model::Own;
use sbor::rust::fmt::Debug;
use sbor::rust::prelude::*;

pub const ACCESS_RULES_BLUEPRINT: &str = "AccessRules";

pub const ACCESS_RULES_CREATE_IDENT: &str = "create";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesCreateInput {
    pub owner_role: OwnerRoleEntry,
    pub roles: BTreeMap<ObjectModuleId, RolesInit>,
}

pub type AccessRulesCreateOutput = Own;

pub const ACCESS_RULES_SET_ROLE_IDENT: &str = "set_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
    pub rule: AccessRule,
}

pub type AccessRulesSetRoleOutput = ();

pub const ACCESS_RULES_LOCK_ROLE_IDENT: &str = "lock_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesLockRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
}

pub type AccessRulesLockRoleOutput = ();

pub const ACCESS_RULES_SET_AND_LOCK_ROLE_IDENT: &str = "set_and_lock_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetAndLockRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
    pub rule: AccessRule,
}

pub type AccessRulesSetAndLockRoleOutput = ();

pub const ACCESS_RULES_SET_OWNER_ROLE_IDENT: &str = "set_owner_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetOwnerRoleInput {
    pub rule: AccessRule,
}

pub type AccessRulesSetOwnerRoleOutput = ();

pub const ACCESS_RULES_LOCK_OWNER_ROLE_IDENT: &str = "lock_owner_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesLockOwnerRoleInput {}

pub type AccessRulesLockOwnerRoleOutput = ();

pub const ACCESS_RULES_SET_AND_LOCK_OWNER_ROLE_IDENT: &str = "set_and_lock_owner_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetAndLockOwnerRoleInput {
    pub rule: AccessRule,
}

pub type AccessRulesSetAndLockOwnerRoleOutput = ();

pub const ACCESS_RULES_GET_ROLE_IDENT: &str = "get_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesGetRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
}

pub type AccessRulesGetRoleOutput = Option<AccessRule>;

pub trait ToRoleEntry {
    fn to_role_entry(self) -> Option<AccessRule>;
}

impl ToRoleEntry for AccessRule {
    fn to_role_entry(self) -> Option<AccessRule> {
        Some(self)
    }
}

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor)]
pub enum FallToOwner {
    OWNER,
}

impl ToRoleEntry for FallToOwner {
    fn to_role_entry(self) -> Option<AccessRule> {
        match self {
            FallToOwner::OWNER => None,
        }
    }
}

pub type RoleDefinition = KeyValueStoreInitEntry<AccessRule>;

#[macro_export]
macro_rules! internal_roles {
    ($role_struct:ident, $($role:ident => $rule:expr;)* ) => ({
        let method_roles = internal_roles_struct!($role_struct, $($role => $rule;)*);

        let mut roles = $crate::blueprints::resource::RolesInit::new();
        for (name, entry) in method_roles.list() {
            roles.set_entry(name, entry);
        }

        roles
    });
}

#[macro_export]
macro_rules! internal_roles_struct {
    ($role_struct:ident, $($role:ident => $rule:expr;)* ) => ({
        $role_struct::<RoleDefinition> {
            $(
                $role: {
                    role_definition_entry!($rule)
                }
            ),*
        }
    });
}

#[macro_export]
macro_rules! role_definition_entry {
    ($rule:expr) => {{
        RoleDefinition {
            value: $rule.to_role_entry(),
            lock: false,
        }
    }};
}

#[macro_export]
macro_rules! roles_init_set_entry {
    ($roles:expr, $key:expr, $value:expr) => {{
        $roles.define_mutable_role($key, $value);
    }};
}

#[macro_export]
macro_rules! roles_init {
    () => ({
        RolesInit::new()
    });
    ( $($key:expr => $value:expr;)* ) => ({
        let mut roles_init = RolesInit::new();
        $(
            $crate::roles_init_set_entry!(roles_init, $key, $value);
        )*
        roles_init
    });
}
